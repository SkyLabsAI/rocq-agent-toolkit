"""Generated by atdpy from type definitions in task_output.atd.

This implements classes for the types defined in 'task_output.atd', providing
methods and functions to convert data from/to JSON.
"""

# Disable flake8 entirely on this file:
# flake8: noqa

# Import annotations to allow forward references
from __future__ import annotations
from dataclasses import dataclass, field
from typing import Any, Callable, Dict, List, NoReturn, Optional, Tuple, Union

import json

############################################################################
# Private functions
############################################################################


def _atd_missing_json_field(type_name: str, json_field_name: str) -> NoReturn:
    raise ValueError(f"missing field '{json_field_name}'"
                     f" in JSON object of type '{type_name}'")


def _atd_bad_json(expected_type: str, json_value: Any) -> NoReturn:
    value_str = str(json_value)
    if len(value_str) > 200:
        value_str = value_str[:200] + '…'

    raise ValueError(f"incompatible JSON value where"
                     f" type '{expected_type}' was expected: '{value_str}'")


def _atd_bad_python(expected_type: str, json_value: Any) -> NoReturn:
    value_str = str(json_value)
    if len(value_str) > 200:
        value_str = value_str[:200] + '…'

    raise ValueError(f"incompatible Python value where"
                     f" type '{expected_type}' was expected: '{value_str}'")


def _atd_read_unit(x: Any) -> None:
    if x is None:
        return x
    else:
        _atd_bad_json('unit', x)


def _atd_read_bool(x: Any) -> bool:
    if isinstance(x, bool):
        return x
    else:
        _atd_bad_json('bool', x)


def _atd_read_int(x: Any) -> int:
    if isinstance(x, int):
        return x
    else:
        _atd_bad_json('int', x)


def _atd_read_float(x: Any) -> float:
    if isinstance(x, (int, float)):
        return x
    else:
        _atd_bad_json('float', x)


def _atd_read_string(x: Any) -> str:
    if isinstance(x, str):
        return x
    else:
        _atd_bad_json('str', x)


def _atd_read_list(
            read_elt: Callable[[Any], Any]
        ) -> Callable[[List[Any]], List[Any]]:
    def read_list(elts: List[Any]) -> List[Any]:
        if isinstance(elts, list):
            return [read_elt(elt) for elt in elts]
        else:
            _atd_bad_json('array', elts)
    return read_list


def _atd_read_assoc_array_into_dict(
            read_key: Callable[[Any], Any],
            read_value: Callable[[Any], Any],
        ) -> Callable[[List[Any]], Dict[Any, Any]]:
    def read_assoc(elts: List[List[Any]]) -> Dict[str, Any]:
        if isinstance(elts, list):
            return {read_key(elt[0]): read_value(elt[1]) for elt in elts}
        else:
            _atd_bad_json('array', elts)
            raise AssertionError('impossible')  # keep mypy happy
    return read_assoc


def _atd_read_assoc_object_into_dict(
            read_value: Callable[[Any], Any]
        ) -> Callable[[Dict[str, Any]], Dict[str, Any]]:
    def read_assoc(elts: Dict[str, Any]) -> Dict[str, Any]:
        if isinstance(elts, dict):
            return {_atd_read_string(k): read_value(v)
                    for k, v in elts.items()}
        else:
            _atd_bad_json('object', elts)
            raise AssertionError('impossible')  # keep mypy happy
    return read_assoc


def _atd_read_assoc_object_into_list(
            read_value: Callable[[Any], Any]
        ) -> Callable[[Dict[str, Any]], List[Tuple[str, Any]]]:
    def read_assoc(elts: Dict[str, Any]) -> List[Tuple[str, Any]]:
        if isinstance(elts, dict):
            return [(_atd_read_string(k), read_value(v))
                    for k, v in elts.items()]
        else:
            _atd_bad_json('object', elts)
            raise AssertionError('impossible')  # keep mypy happy
    return read_assoc


def _atd_read_nullable(read_elt: Callable[[Any], Any]) \
        -> Callable[[Optional[Any]], Optional[Any]]:
    def read_nullable(x: Any) -> Any:
        if x is None:
            return None
        else:
            return read_elt(x)
    return read_nullable


def _atd_read_option(read_elt: Callable[[Any], Any]) \
        -> Callable[[Optional[Any]], Optional[Any]]:
    def read_option(x: Any) -> Any:
        if x == 'None':
            return None
        elif isinstance(x, List) and len(x) == 2 and x[0] == 'Some':
            return read_elt(x[1])
        else:
            _atd_bad_json('option', x)
            raise AssertionError('impossible')  # keep mypy happy
    return read_option


def _atd_write_unit(x: Any) -> None:
    if x is None:
        return x
    else:
        _atd_bad_python('unit', x)


def _atd_write_bool(x: Any) -> bool:
    if isinstance(x, bool):
        return x
    else:
        _atd_bad_python('bool', x)


def _atd_write_int(x: Any) -> int:
    if isinstance(x, int):
        return x
    else:
        _atd_bad_python('int', x)


def _atd_write_float(x: Any) -> float:
    if isinstance(x, (int, float)):
        return x
    else:
        _atd_bad_python('float', x)


def _atd_write_string(x: Any) -> str:
    if isinstance(x, str):
        return x
    else:
        _atd_bad_python('str', x)


def _atd_write_list(
            write_elt: Callable[[Any], Any]
        ) -> Callable[[List[Any]], List[Any]]:
    def write_list(elts: List[Any]) -> List[Any]:
        if isinstance(elts, list):
            return [write_elt(elt) for elt in elts]
        else:
            _atd_bad_python('list', elts)
    return write_list


def _atd_write_assoc_dict_to_array(
            write_key: Callable[[Any], Any],
            write_value: Callable[[Any], Any]
        ) -> Callable[[Dict[Any, Any]], List[Tuple[Any, Any]]]:
    def write_assoc(elts: Dict[str, Any]) -> List[Tuple[str, Any]]:
        if isinstance(elts, dict):
            return [(write_key(k), write_value(v)) for k, v in elts.items()]
        else:
            _atd_bad_python('Dict[str, <value type>]]', elts)
            raise AssertionError('impossible')  # keep mypy happy
    return write_assoc


def _atd_write_assoc_dict_to_object(
            write_value: Callable[[Any], Any]
        ) -> Callable[[Dict[str, Any]], Dict[str, Any]]:
    def write_assoc(elts: Dict[str, Any]) -> Dict[str, Any]:
        if isinstance(elts, dict):
            return {_atd_write_string(k): write_value(v)
                    for k, v in elts.items()}
        else:
            _atd_bad_python('Dict[str, <value type>]', elts)
            raise AssertionError('impossible')  # keep mypy happy
    return write_assoc


def _atd_write_assoc_list_to_object(
            write_value: Callable[[Any], Any],
        ) -> Callable[[List[Any]], Dict[str, Any]]:
    def write_assoc(elts: List[List[Any]]) -> Dict[str, Any]:
        if isinstance(elts, list):
            return {_atd_write_string(elt[0]): write_value(elt[1])
                    for elt in elts}
        else:
            _atd_bad_python('List[Tuple[<key type>, <value type>]]', elts)
            raise AssertionError('impossible')  # keep mypy happy
    return write_assoc


def _atd_write_nullable(write_elt: Callable[[Any], Any]) \
        -> Callable[[Optional[Any]], Optional[Any]]:
    def write_nullable(x: Any) -> Any:
        if x is None:
            return None
        else:
            return write_elt(x)
    return write_nullable


def _atd_write_option(write_elt: Callable[[Any], Any]) \
        -> Callable[[Optional[Any]], Optional[Any]]:
    def write_option(x: Any) -> Any:
        if x is None:
            return 'None'
        else:
            return ['Some', write_elt(x)]
    return write_option


############################################################################
# Public classes
############################################################################


@dataclass
class CodeInfo:
    """Original type: code_info = { ... }"""

    git_repo: str
    git_sha: str
    file_path: str
    class_name: str
    start_line: int

    @classmethod
    def from_json(cls, x: Any) -> 'CodeInfo':
        if isinstance(x, dict):
            return cls(
                git_repo=_atd_read_string(x['git_repo']) if 'git_repo' in x else _atd_missing_json_field('CodeInfo', 'git_repo'),
                git_sha=_atd_read_string(x['git_sha']) if 'git_sha' in x else _atd_missing_json_field('CodeInfo', 'git_sha'),
                file_path=_atd_read_string(x['file_path']) if 'file_path' in x else _atd_missing_json_field('CodeInfo', 'file_path'),
                class_name=_atd_read_string(x['class_name']) if 'class_name' in x else _atd_missing_json_field('CodeInfo', 'class_name'),
                start_line=_atd_read_int(x['start_line']) if 'start_line' in x else _atd_missing_json_field('CodeInfo', 'start_line'),
            )
        else:
            _atd_bad_json('CodeInfo', x)

    def to_json(self) -> Any:
        res: Dict[str, Any] = {}
        res['git_repo'] = _atd_write_string(self.git_repo)
        res['git_sha'] = _atd_write_string(self.git_sha)
        res['file_path'] = _atd_write_string(self.file_path)
        res['class_name'] = _atd_write_string(self.class_name)
        res['start_line'] = _atd_write_int(self.start_line)
        return res

    @classmethod
    def from_json_string(cls, x: str) -> 'CodeInfo':
        return cls.from_json(json.loads(x))

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class AgentMetadata:
    """Original type: agent_metadata = { ... }"""

    model_name: str
    model_config: Dict[str, str]
    sub_agents: List[AgentMetadata]
    code_info: CodeInfo

    @classmethod
    def from_json(cls, x: Any) -> 'AgentMetadata':
        if isinstance(x, dict):
            return cls(
                model_name=_atd_read_string(x['model_name']) if 'model_name' in x else _atd_missing_json_field('AgentMetadata', 'model_name'),
                model_config=_atd_read_assoc_array_into_dict(_atd_read_string, _atd_read_string)(x['model_config']) if 'model_config' in x else _atd_missing_json_field('AgentMetadata', 'model_config'),
                sub_agents=_atd_read_list(AgentMetadata.from_json)(x['sub_agents']) if 'sub_agents' in x else _atd_missing_json_field('AgentMetadata', 'sub_agents'),
                code_info=CodeInfo.from_json(x['code_info']) if 'code_info' in x else _atd_missing_json_field('AgentMetadata', 'code_info'),
            )
        else:
            _atd_bad_json('AgentMetadata', x)

    def to_json(self) -> Any:
        res: Dict[str, Any] = {}
        res['model_name'] = _atd_write_string(self.model_name)
        res['model_config'] = _atd_write_assoc_dict_to_array(_atd_write_string, _atd_write_string)(self.model_config)
        res['sub_agents'] = _atd_write_list((lambda x: x.to_json()))(self.sub_agents)
        res['code_info'] = (lambda x: x.to_json())(self.code_info)
        return res

    @classmethod
    def from_json_string(cls, x: str) -> 'AgentMetadata':
        return cls.from_json(json.loads(x))

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class TokenCounts:
    """Original type: token_counts = { ... }"""

    input_tokens: int
    output_tokens: int
    total_tokens: int

    @classmethod
    def from_json(cls, x: Any) -> 'TokenCounts':
        if isinstance(x, dict):
            return cls(
                input_tokens=_atd_read_int(x['input_tokens']) if 'input_tokens' in x else _atd_missing_json_field('TokenCounts', 'input_tokens'),
                output_tokens=_atd_read_int(x['output_tokens']) if 'output_tokens' in x else _atd_missing_json_field('TokenCounts', 'output_tokens'),
                total_tokens=_atd_read_int(x['total_tokens']) if 'total_tokens' in x else _atd_missing_json_field('TokenCounts', 'total_tokens'),
            )
        else:
            _atd_bad_json('TokenCounts', x)

    def to_json(self) -> Any:
        res: Dict[str, Any] = {}
        res['input_tokens'] = _atd_write_int(self.input_tokens)
        res['output_tokens'] = _atd_write_int(self.output_tokens)
        res['total_tokens'] = _atd_write_int(self.total_tokens)
        return res

    @classmethod
    def from_json_string(cls, x: str) -> 'TokenCounts':
        return cls.from_json(json.loads(x))

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class TelemetryEntry:
    """Original type: telemetry_entry = { ... }"""

    timestamp_utc: str
    event_type: str
    data: Dict[str, str]

    @classmethod
    def from_json(cls, x: Any) -> 'TelemetryEntry':
        if isinstance(x, dict):
            return cls(
                timestamp_utc=_atd_read_string(x['timestamp_utc']) if 'timestamp_utc' in x else _atd_missing_json_field('TelemetryEntry', 'timestamp_utc'),
                event_type=_atd_read_string(x['event_type']) if 'event_type' in x else _atd_missing_json_field('TelemetryEntry', 'event_type'),
                data=_atd_read_assoc_array_into_dict(_atd_read_string, _atd_read_string)(x['data']) if 'data' in x else _atd_missing_json_field('TelemetryEntry', 'data'),
            )
        else:
            _atd_bad_json('TelemetryEntry', x)

    def to_json(self) -> Any:
        res: Dict[str, Any] = {}
        res['timestamp_utc'] = _atd_write_string(self.timestamp_utc)
        res['event_type'] = _atd_write_string(self.event_type)
        res['data'] = _atd_write_assoc_dict_to_array(_atd_write_string, _atd_write_string)(self.data)
        return res

    @classmethod
    def from_json_string(cls, x: str) -> 'TelemetryEntry':
        return cls.from_json(json.loads(x))

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class Success:
    """Original type: task_status = [ ... | Success | ... ]"""

    @property
    def kind(self) -> str:
        """Name of the class representing this variant."""
        return 'Success'

    @staticmethod
    def to_json() -> Any:
        return 'Success'

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class Failure:
    """Original type: task_status = [ ... | Failure | ... ]"""

    @property
    def kind(self) -> str:
        """Name of the class representing this variant."""
        return 'Failure'

    @staticmethod
    def to_json() -> Any:
        return 'Failure'

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class TaskStatus:
    """Original type: task_status = [ ... ]"""

    value: Union[Success, Failure]

    @property
    def kind(self) -> str:
        """Name of the class representing this variant."""
        return self.value.kind

    @classmethod
    def from_json(cls, x: Any) -> 'TaskStatus':
        if isinstance(x, str):
            if x == 'Success':
                return cls(Success())
            if x == 'Failure':
                return cls(Failure())
            _atd_bad_json('TaskStatus', x)
        _atd_bad_json('TaskStatus', x)

    def to_json(self) -> Any:
        return self.value.to_json()

    @classmethod
    def from_json_string(cls, x: str) -> 'TaskStatus':
        return cls.from_json(json.loads(x))

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class ResourceUsage:
    """Original type: resource_usage = { ... }"""

    execution_time_sec: float
    cpu_time_sec: float
    gpu_time_sec: float

    @classmethod
    def from_json(cls, x: Any) -> 'ResourceUsage':
        if isinstance(x, dict):
            return cls(
                execution_time_sec=_atd_read_float(x['execution_time_sec']) if 'execution_time_sec' in x else _atd_missing_json_field('ResourceUsage', 'execution_time_sec'),
                cpu_time_sec=_atd_read_float(x['cpu_time_sec']) if 'cpu_time_sec' in x else _atd_missing_json_field('ResourceUsage', 'cpu_time_sec'),
                gpu_time_sec=_atd_read_float(x['gpu_time_sec']) if 'gpu_time_sec' in x else _atd_missing_json_field('ResourceUsage', 'gpu_time_sec'),
            )
        else:
            _atd_bad_json('ResourceUsage', x)

    def to_json(self) -> Any:
        res: Dict[str, Any] = {}
        res['execution_time_sec'] = _atd_write_float(self.execution_time_sec)
        res['cpu_time_sec'] = _atd_write_float(self.cpu_time_sec)
        res['gpu_time_sec'] = _atd_write_float(self.gpu_time_sec)
        return res

    @classmethod
    def from_json_string(cls, x: str) -> 'ResourceUsage':
        return cls.from_json(json.loads(x))

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class ProofOutputs:
    """Original type: proof_outputs = { ... }"""

    generated_proof: str
    telemetry_trace: List[TelemetryEntry]

    @classmethod
    def from_json(cls, x: Any) -> 'ProofOutputs':
        if isinstance(x, dict):
            return cls(
                generated_proof=_atd_read_string(x['generated_proof']) if 'generated_proof' in x else _atd_missing_json_field('ProofOutputs', 'generated_proof'),
                telemetry_trace=_atd_read_list(TelemetryEntry.from_json)(x['telemetry_trace']) if 'telemetry_trace' in x else _atd_missing_json_field('ProofOutputs', 'telemetry_trace'),
            )
        else:
            _atd_bad_json('ProofOutputs', x)

    def to_json(self) -> Any:
        res: Dict[str, Any] = {}
        res['generated_proof'] = _atd_write_string(self.generated_proof)
        res['telemetry_trace'] = _atd_write_list((lambda x: x.to_json()))(self.telemetry_trace)
        return res

    @classmethod
    def from_json_string(cls, x: str) -> 'ProofOutputs':
        return cls.from_json(json.loads(x))

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class Metrics:
    """Original type: metrics = { ... }"""

    llm_invocation_count: int
    token_counts: TokenCounts
    resource_usage: ResourceUsage

    @classmethod
    def from_json(cls, x: Any) -> 'Metrics':
        if isinstance(x, dict):
            return cls(
                llm_invocation_count=_atd_read_int(x['llm_invocation_count']) if 'llm_invocation_count' in x else _atd_missing_json_field('Metrics', 'llm_invocation_count'),
                token_counts=TokenCounts.from_json(x['token_counts']) if 'token_counts' in x else _atd_missing_json_field('Metrics', 'token_counts'),
                resource_usage=ResourceUsage.from_json(x['resource_usage']) if 'resource_usage' in x else _atd_missing_json_field('Metrics', 'resource_usage'),
            )
        else:
            _atd_bad_json('Metrics', x)

    def to_json(self) -> Any:
        res: Dict[str, Any] = {}
        res['llm_invocation_count'] = _atd_write_int(self.llm_invocation_count)
        res['token_counts'] = (lambda x: x.to_json())(self.token_counts)
        res['resource_usage'] = (lambda x: x.to_json())(self.resource_usage)
        return res

    @classmethod
    def from_json_string(cls, x: str) -> 'Metrics':
        return cls.from_json(json.loads(x))

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class Timeout:
    """Original type: failure_reason = [ ... | Timeout | ... ]"""

    @property
    def kind(self) -> str:
        """Name of the class representing this variant."""
        return 'Timeout'

    @staticmethod
    def to_json() -> Any:
        return 'Timeout'

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class ProofVerificationFailed:
    """Original type: failure_reason = [ ... | ProofVerificationFailed | ... ]"""

    @property
    def kind(self) -> str:
        """Name of the class representing this variant."""
        return 'ProofVerificationFailed'

    @staticmethod
    def to_json() -> Any:
        return 'ProofVerificationFailed'

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class MaxLLMCallsReached:
    """Original type: failure_reason = [ ... | MaxLLMCallsReached | ... ]"""

    @property
    def kind(self) -> str:
        """Name of the class representing this variant."""
        return 'MaxLLMCallsReached'

    @staticmethod
    def to_json() -> Any:
        return 'MaxLLMCallsReached'

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class ExecutionError:
    """Original type: failure_reason = [ ... | ExecutionError | ... ]"""

    @property
    def kind(self) -> str:
        """Name of the class representing this variant."""
        return 'ExecutionError'

    @staticmethod
    def to_json() -> Any:
        return 'ExecutionError'

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class Other:
    """Original type: failure_reason = [ ... | Other of ... | ... ]"""

    value: str

    @property
    def kind(self) -> str:
        """Name of the class representing this variant."""
        return 'Other'

    def to_json(self) -> Any:
        return ['Other', _atd_write_string(self.value)]

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class FailureReason:
    """Original type: failure_reason = [ ... ]"""

    value: Union[Timeout, ProofVerificationFailed, MaxLLMCallsReached, ExecutionError, Other]

    @property
    def kind(self) -> str:
        """Name of the class representing this variant."""
        return self.value.kind

    @classmethod
    def from_json(cls, x: Any) -> 'FailureReason':
        if isinstance(x, str):
            if x == 'Timeout':
                return cls(Timeout())
            if x == 'ProofVerificationFailed':
                return cls(ProofVerificationFailed())
            if x == 'MaxLLMCallsReached':
                return cls(MaxLLMCallsReached())
            if x == 'ExecutionError':
                return cls(ExecutionError())
            _atd_bad_json('FailureReason', x)
        if isinstance(x, List) and len(x) == 2:
            cons = x[0]
            if cons == 'Other':
                return cls(Other(_atd_read_string(x[1])))
            _atd_bad_json('FailureReason', x)
        _atd_bad_json('FailureReason', x)

    def to_json(self) -> Any:
        return self.value.to_json()

    @classmethod
    def from_json_string(cls, x: str) -> 'FailureReason':
        return cls.from_json(json.loads(x))

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class TaskOutput:
    """Original type: task_output = { ... }"""

    run_id: str
    agent_metadata: AgentMetadata
    task_id: str
    timestamp_utc: str
    status: TaskStatus
    failure_reason: Optional[FailureReason]
    metrics: Optional[Metrics]
    outputs: ProofOutputs

    @classmethod
    def from_json(cls, x: Any) -> 'TaskOutput':
        if isinstance(x, dict):
            return cls(
                run_id=_atd_read_string(x['run_id']) if 'run_id' in x else _atd_missing_json_field('TaskOutput', 'run_id'),
                agent_metadata=AgentMetadata.from_json(x['agent_metadata']) if 'agent_metadata' in x else _atd_missing_json_field('TaskOutput', 'agent_metadata'),
                task_id=_atd_read_string(x['task_id']) if 'task_id' in x else _atd_missing_json_field('TaskOutput', 'task_id'),
                timestamp_utc=_atd_read_string(x['timestamp_utc']) if 'timestamp_utc' in x else _atd_missing_json_field('TaskOutput', 'timestamp_utc'),
                status=TaskStatus.from_json(x['status']) if 'status' in x else _atd_missing_json_field('TaskOutput', 'status'),
                failure_reason=_atd_read_option(FailureReason.from_json)(x['failure_reason']) if 'failure_reason' in x else _atd_missing_json_field('TaskOutput', 'failure_reason'),
                metrics=_atd_read_option(Metrics.from_json)(x['metrics']) if 'metrics' in x else _atd_missing_json_field('TaskOutput', 'metrics'),
                outputs=ProofOutputs.from_json(x['outputs']) if 'outputs' in x else _atd_missing_json_field('TaskOutput', 'outputs'),
            )
        else:
            _atd_bad_json('TaskOutput', x)

    def to_json(self) -> Any:
        res: Dict[str, Any] = {}
        res['run_id'] = _atd_write_string(self.run_id)
        res['agent_metadata'] = (lambda x: x.to_json())(self.agent_metadata)
        res['task_id'] = _atd_write_string(self.task_id)
        res['timestamp_utc'] = _atd_write_string(self.timestamp_utc)
        res['status'] = (lambda x: x.to_json())(self.status)
        res['failure_reason'] = _atd_write_option((lambda x: x.to_json()))(self.failure_reason)
        res['metrics'] = _atd_write_option((lambda x: x.to_json()))(self.metrics)
        res['outputs'] = (lambda x: x.to_json())(self.outputs)
        return res

    @classmethod
    def from_json_string(cls, x: str) -> 'TaskOutput':
        return cls.from_json(json.loads(x))

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)
